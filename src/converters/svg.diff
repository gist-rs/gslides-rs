--- a/gslides-rs/src/converters/svg.rs
+++ b/gslides-rs/src/converters/svg.rs
@@ -320,6 +320,7 @@
 // considering inheritance. This is complex due to matching text runs.
 // Let's simplify: find the *first* relevant style in the placeholder for now.
 fn get_placeholder_default_text_style(placeholder_element: &PageElement) -> Option<TextStyle> {
+    // TODO: This is a simplification. Real inheritance might involve list styles, paragraph styles, etc.
     match &placeholder_element.element_kind {
         PageElementKind::Shape(shape) => {
             if let Some(text) = &shape.text {
@@ -343,7 +344,6 @@
 // --- Conversion Functions ---
 
 /// Converts the text content of a shape or cell into SVG `<text>` and `<tspan>` elements.
-/// Converts the text content of a shape or cell into SVG `<text>` and `<tspan>` elements.
 fn convert_text_content_to_svg(
     text_content: &TextContent,
     // Add context needed for style resolution
@@ -360,7 +360,7 @@
 
     // Store paragraph-level info (bullets, potentially specific paragraph styles if not pre-merged)
     let mut para_bullets: HashMap<u32, String> = HashMap::new();
-    // Note: We now assume paragraph style (like alignment) is pre-resolved in effective_paragraph_style
+    // Note: Paragraph style (like alignment) is assumed to be pre-resolved in effective_paragraph_style
 
     for element in text_elements {
         if let Some(TextElementKind::ParagraphMarker(pm)) = &element.kind {
@@ -368,7 +368,7 @@
                 // TODO: Handle bullet glyph lookup/rendering - this needs list context from TextContent.lists
                 if let Some(bullet) = &pm.bullet {
                     // Lookup list properties based on bullet.list_id and nesting level
-                    // For now, use placeholder glyph
+                    // For now, use placeholder glyph - actual rendering is complex
                     let bullet_text = bullet.glyph.as_deref().unwrap_or("* ").to_string(); // Default bullet
                     para_bullets.insert(start_index, bullet_text);
                 }
@@ -385,7 +385,7 @@
         DEFAULT_FONT_SIZE_PT * 1.2
     };
     let mut first_line_in_paragraph = true;
-    // Use the pre-resolved paragraph style for alignment
+    // Use the pre-resolved paragraph style for alignment and other para props
     let current_para_style = effective_paragraph_style;
 
     for element in text_elements {
@@ -394,7 +394,7 @@
         match &element.kind {
             Some(TextElementKind::ParagraphMarker(_)) => {
                 // Start of a new paragraph.
-                // Paragraph style (alignment) is already handled by the effective_paragraph_style passed in.
+                // Paragraph style (alignment, etc.) is handled by the effective_paragraph_style passed in.
 
                 if !first_line_in_paragraph {
                     // Move down for the new paragraph (add space equivalent to line height)
@@ -405,7 +405,7 @@
                                                 // Handle bullet rendering (if starting a new line)
                 if let Some(_bullet_text) = para_bullets.get(&start_index) {
                     // TODO: How to render bullets accurately? Prepend a tspan?
-                    // This might mess up alignment. Let's omit bullets for now to focus on text.
+                    // This might mess up alignment and requires complex positioning. Omit bullets for now.
                     // write!(svg_output, "<tspan>{}</tspan>", escape_svg_text(bullet_text))?;
                 }
             }
@@ -430,7 +430,7 @@
                         element_width,
                     )?;
 
-                    // Use dominant-baseline="hanging" or adjust y. Adjust y by font size from the run's style.
+                    // Adjust y based on font size to approximate top alignment within the line height.
                     let run_font_size_pt = dimension_to_pt(final_run_style.font_size.as_ref());
                     let y_pos = current_y
                         + if run_font_size_pt > 0.0 {
@@ -449,7 +449,7 @@
                     first_line_in_paragraph = false; // Subsequent runs in this line use tspan relative to this <text>
                 } else {
                     // --- Sticking to simpler approach: New <text> for first run ---
-                    // The initial approach has limitations. A full implementation would group by paragraph.
+                    // The initial approach has limitations. A full implementation would group runs by paragraph and handle line breaks.
                     // For now, we only render the *first* text run of each paragraph correctly positioned.
                     eprintln!("Warning: Subsequent TextRuns in the same paragraph are currently skipped in SVG conversion.");
                 }
@@ -482,6 +482,7 @@
                         transform_x,
                         element_width,
                     )?;
+                    // Adjust y based on font size
                     let run_font_size_pt = dimension_to_pt(final_autotext_style.font_size.as_ref());
                     let y_pos = current_y
                         + if run_font_size_pt > 0.0 {
@@ -530,6 +531,7 @@
                 // Start a new paragraph in HTML
                 write!(html_output, "<p style=\"margin:0; padding:0;\">")?; // Basic paragraph styling
             }
+            // NOTE: Need to close the previous </p> correctly here if the previous element was a run/autotext.
             Some(TextElementKind::TextRun(tr)) => {
                 let content = tr.content.as_deref().unwrap_or("");
                 if content.is_empty() {
@@ -596,7 +598,7 @@
                 }
                 // Apply styles similar to TextRun
                 // ... (style conversion logic omitted for brevity, similar to TextRun above) ...
-                let html_content = escape_html_text(content).replace('\n', "<br/>");
+                let html_content = escape_html_text(content).replace('\n', "<br/>"); // Replace newline with <br>
                 // write!(html_output, r#"<span style="{}">{}</span>"#, span_style, html_content)?;
                 write!(html_output, "<span>{}</span>", html_content)?; // Simplified without full style conversion for brevity
             }
@@ -609,7 +611,7 @@
         // If the last element was a para marker without content, maybe remove it or add &nbsp;?
     } else if html_output.contains("<p") && !html_output.ends_with("</p>") {
         // This check is weak. Correct paragraph handling is needed.
-        // write!(html_output, "</p>")?;
+        // TODO: Fix paragraph closing logic. Maybe always close </p> before starting a new <p> or at the end?
     }
 
     Ok(())
@@ -634,7 +636,7 @@
 
     // Resolve effective styles
     let mut effective_text_style_base = TextStyle::default(); // Start with default
-    let mut effective_paragraph_style: Option<ParagraphStyle> = None;
+    let mut effective_paragraph_style: Option<ParagraphStyle> = None; // Start with no specific paragraph style
 
     if let Some(placeholder) = &shape.placeholder {
         if let Some(layout_id) = slide_layout_id {
@@ -651,8 +653,7 @@
                     effective_text_style_base = placeholder_base_style;
                 }
 
-                // Attempt to get paragraph style (like alignment) from placeholder's *first* paragraph marker
-                // This is also an approximation.
+                // Attempt to get paragraph style (like alignment) from placeholder's *first* paragraph marker (approximation)
                 if let Some(placeholder_shape) = placeholder_element.element_kind.as_shape() {
                     if let Some(text) = &placeholder_shape.text {
                         if let Some(elements) = &text.text_elements {
@@ -677,7 +678,7 @@
             for element in elements {
                 if let Some(TextElementKind::ParagraphMarker(pm)) = &element.kind {
                     if let Some(style) = &pm.style {
-                        // Merge? Or just override? Let's override for simplicity.
+                        // Override inherited paragraph style if slide element has one defined (using the first one found).
                         effective_paragraph_style = Some(style.clone());
                         break;
                     }
@@ -688,7 +689,7 @@
         convert_text_content_to_svg(
             text,
             effective_paragraph_style.as_ref(),
-            &effective_text_style_base, // Pass the resolved base style
+            &effective_text_style_base, // Pass the resolved base text style
             tx,
             ty,
             width,
@@ -711,7 +712,7 @@
     let width = dimension_to_pt(size.and_then(|s| s.width.as_ref()));
     let height = dimension_to_pt(size.and_then(|s| s.height.as_ref()));
 
-    if width <= 0.0 || height <= 0.0 {
+    if width <= 0.0 || height <= 0.0 { // Avoid creating zero-size objects
         eprintln!("Warning: Skipping table with zero or negative dimensions.");
         return Ok(());
     }
@@ -775,7 +776,7 @@
     svg_output: &mut String,
 ) -> Result<()> {
     // Add data-object-id for traceability
-    write!(svg_output, r#"<g data-object-id="{}">"#, element.object_id)?;
+    writeln!(svg_output, r#"<g data-object-id="{}">"#, element.object_id)?;
 
     match &element.element_kind {
         PageElementKind::Shape(shape) => {
@@ -802,7 +803,7 @@
         PageElementKind::ElementGroup(group) => {
             let mut group_attrs = String::new();
             apply_transform(element.transform.as_ref(), &mut group_attrs)?;
-            writeln!(svg_output, "{}> <!-- Start Group -->", group_attrs)?;
+            writeln!(svg_output, "<g{}> <!-- Start Group -->", group_attrs)?;
 
             for child_element in &group.children {
                 // Pass context down recursively
@@ -815,7 +816,7 @@
                     svg_output,
                 )?;
             }
-            write!(svg_output, "<!-- End Group Content -->")?;
+            writeln!(svg_output, "</g> <!-- End Group -->")?;
         }
         PageElementKind::Image(_) => {
             // Placeholder for Image (unchanged)
@@ -824,13 +825,13 @@
             let height = dimension_to_pt(element.size.as_ref().and_then(|s| s.height.as_ref()));
             write!(
                 svg_output,
-                r#"<rect x="{}" y="{}" width="{}" height="{}" {} style="fill:#e0e0e0; stroke:gray; fill-opacity:0.5;" />"#,
+                r#"  <rect x="{}" y="{}" width="{}" height="{}"{} style="fill:#e0e0e0; stroke:gray; fill-opacity:0.5;" />"#,
                 tx, ty, width, height, img_attrs
             )?;
             write!(
                 svg_output,
-                r#"<text x="{}" y="{}" dy="1em" style="font-size:8pt; fill:gray;">Image Placeholder</text>"#,
-                tx + 2.0,
+                r#"<text x="{}" y="{}" dy="1em" style="font-family:sans-serif; font-size:8pt; fill:gray;">Image Placeholder</text>"#,
+                tx + 2.0, // Small offset for text
                 ty + 2.0
             )?;
         }
@@ -842,7 +843,7 @@
             let height = dimension_to_pt(element.size.as_ref().and_then(|s| s.height.as_ref()));
             write!(
                 svg_output,
-                r#"<line x1="{}" y1="{}" x2="{}" y2="{}" {} style="stroke:gray; stroke-width:1;" />"#,
+                r#"  <line x1="{}" y1="{}" x2="{}" y2="{}"{} style="stroke:gray; stroke-width:1;" />"#,
                 tx,
                 ty,
                 tx + width,
@@ -851,8 +852,8 @@
             )?;
             write!(
                 svg_output,
-                r#"<text x="{}" y="{}" dy="1em" style="font-size:8pt; fill:gray;">Line Placeholder</text>"#,
-                tx + 2.0,
+                r#"<text x="{}" y="{}" dy="1em" style="font-family:sans-serif; font-size:8pt; fill:gray;">Line Placeholder</text>"#,
+                tx + 2.0, // Small offset
                 ty + 2.0
             )?;
         }
@@ -871,18 +872,18 @@
 
             write!(
                 svg_output,
-                r#"<rect x="{}" y="{}" width="{}" height="{}" {} style="fill:#f0f0f0; stroke:lightgray; stroke-dasharray: 3 3; fill-opacity:0.5;" />"#,
+                r#"  <rect x="{}" y="{}" width="{}" height="{}"{} style="fill:#f0f0f0; stroke:lightgray; stroke-dasharray: 3 3; fill-opacity:0.5;" />"#,
                 tx, ty, width, height, ph_attrs
             )?;
             write!(
                 svg_output,
-                r#"<text x="{}" y="{}" dy="1em" style="font-size:8pt; fill:gray;">{} Placeholder</text>"#,
+                r#"<text x="{}" y="{}" dy="1em" style="font-family:sans-serif; font-size:8pt; fill:gray;">{} Placeholder</text>"#,
                 tx + 2.0,
                 ty + 2.0,
                 type_name
             )?;
         }
     }
-
     write!(svg_output, "</g>")?; // Close data-object-id group
     Ok(())
 }